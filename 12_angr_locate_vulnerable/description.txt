It's past 6am at this point. You've been here all night.

You hear the sound of a door opening and closing.

Footsteps.

You frantically close all of the windows on Jeff's computer, turn off the moni-
tor, and stand up to meet whoever has arrived.

It's Jeff.

-- What are you doing here?

-- I could ask you the same.

He has a point.

-- I was just leaving.

You pick up your things that you had set down at your cubicle (luckily) and walk 
across the floor to the exit door.

The entire car ride home, you construct a plan to continue your investigation.
This time, you had to be more aggressive. You couldn't be looking for backdoors
anymore. Anything with a backdoor wouldn't be important enough. Otherwise, it
would be made more secure.

After a well deserved nap and a meal, you hop on your computer.

You recall a set of binaries Kelly sent you about a month ago that you never got
around to cracking. They were difficult. They didn't seem to have a backdoor,
but that was before you began playing around with Angr. It is time to revisit
them.

You have an idea:
You might be able to find a buffer overflow. The program calls strcmp, a known
vulnerable function in libc. Perhaps you could identify an input that would call
strcmp on input from the user. You can then enter more bytes than the buffer in
hopes that it would cause a segfault, causing the program to crash.
to jot down an outline of your exploit.
1. Handle scanf. It appears to input an unsigned integer and a string of length
   32, in that order.
2. Search for the function strcmp. 
3. Check to determine if strcmp takes input from the user.
4. Solve for the input string that will overwrite more characters than the buf-
   fer length.
5. Check to see that the program segfaults and crashes.

The Internet reveals documentation for some useful functions:

- # Determines if there exists solutions to the symbolic values given the state 
- # and the expressions.
- simuvex.s_state.SimState.satisfiable(extra_constraints=(expression0, expression1, ...))
- 
- # Determines if the bitvector parameter is symbolic.
- claripy.SolverEngine.symbolic(bitvector)
-
- # The current instruction pointer as a concrete value.
- simuvex.s_state.SimState.ip.args[0]
-
- # Manually step each path in the pathgroup. This function, in combination with 
- # some sort of check function to determine when to stop can be used to create 
- # a fully customizable version of 'explore'.
- angr.path_group.PathGroup.step()
-
- # An array containing all of the active paths. A check function to be combined 
- # with the function to create a customizable 'explore' might iterate through
- # this list.
- angr.path_gorup.PathGroup.active
